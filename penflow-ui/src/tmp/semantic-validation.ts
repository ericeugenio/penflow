import { FlowTaskLinkedList, FlowTaskNode } from "@/lib/ds/linkedlist-tasks";
import { getPrintableType } from "@/lib/utils";
import * as validations from "@/tmp/semantic-validation-errors";
import type {FlowVariable, NamedFlowVariable} from "@/types/FlowVariable";
import type {Task} from "@/types/Task";

export function filterVariablesByScope(
    variables: {[key: string]: FlowVariable},
    scope: "in" | "local" | "out"
): {[key: string]: FlowVariable} {
    return Object.fromEntries(
        Object.entries(variables).filter(([_, meta]) => meta.scope === scope)
    );
}

export function semanticValidation(
    flowTasks: FlowTaskLinkedList,
    allVariables: {[key: string]: FlowVariable},
    tasks: Task[]
): void {
    // We keep track of the variables as they are declared, starting with the inputs
    const inputVariables = {...filterVariablesByScope(allVariables, "in")};
    // Besides the variable we will store where it has been declared
    const inputVariablesOrigins: {[key: string]: string[]} = Object.fromEntries(
        Object.entries(inputVariables as object).map((name, _) => [name, ["io"]]
        ));
    _semanticValidation(
        flowTasks,
        (flowTasks.head as FlowTaskNode),
        allVariables,
        inputVariables,
        inputVariablesOrigins,
        tasks
    );
}

export function _semanticValidation(
    flowTasks: FlowTaskLinkedList,
    start: FlowTaskNode | null,
    allVariables: {[key: string]: FlowVariable},
    curVariables: {[key: string]: FlowVariable},
    curVariablesOrigin: {[key: string]: string[]},
    tasks: Task[]
): void {
    // Iterate tasks in order and validate, subtasks are traversed recursively:
    //   1. Used variables by task properties...
    //     a) Are previously declared as inputs or in previous tasks
    //     b) Match property type
    //   2. Variables generated by tasks outputs...
    //     a) Don't redeclare a variable name
    //     b) Don't use a reserved keyword (new)
    let current = start;
    while (current != null) {
        let flowTask = current.value;
        let task = tasks.find((t) => t.name == flowTask.name)!;
        for (const [name, value] of Object.entries(flowTask.properties)) {
            let errors = flowTask.errors[name] || [];
            if (typeof value === "string") {
                // 1.a Validate used variable is declared
                errors = validations.validate(errors, validations.ERR_INVALID_VARIABLE(flowTask.id, value), (
                    value.startsWith("$")
                    && !(value.substring(1) in curVariables)
                    && !(value.substring(1) in allVariables)
                ));
                // 1.a Validate used variable is declared previous to usage
                errors = validations.validate(errors, validations.ERR_FORWARD_REFERENCE_VARIABLE(flowTask.id, value), (
                    value.startsWith("$")
                    && !(value.substring(1) in curVariables)
                    && value.substring(1) in allVariables
                ));
                // 1.b Validate variable has correct type
                errors = validations.validate(errors,
                    validations.ERR_INVALID_VARIABLE_TYPE(
                        flowTask.id,
                        getPrintableType(task.properties![name]),
                        getPrintableType(curVariables[value.substring(1)])
                    ),
                    (
                        value.startsWith("$")
                        && value.substring(1) in curVariables
                        && !(curVariables[value.substring(1)].type === "any" || task.properties![name].type === "any")
                        && curVariables[value.substring(1)].type != task.properties![name].type
                    )
                );
            }
            // Set errors
            if (errors.length != 0) {
                flowTask.errors = {
                    ...flowTask.errors,
                    [name]: errors
                };
            } else {
                const {[name]:_, ...remainingErrors} = flowTask.errors;
                flowTask.errors = {...remainingErrors};
            }
        }
        // Validate and add generated variables
        if (Object.keys(flowTask.outputs as object).length > 0) {
            for (const [name, value] of Object.entries(flowTask.outputs)) {
                if (value === "") {
                    continue;
                }
                let errors = flowTask.errors[name] || [];
                // 2.a Validate duplicate name
                errors = validations.validate(errors, validations.ERR_REDECLARED_VARIABLE(flowTask.id, value), (
                    value.toLowerCase() in curVariables
                ));
                if (value.toLowerCase() in curVariables) {
                    // Add error in all duplicate declarations (except input)
                    for (const origins of Object.values(curVariablesOrigin)) {
                        origins.forEach((origin) => {
                            if (origin != "io") {
                                let originTask = flowTasks.search(origin)!.value;
                                originTask.errors[name] = validations.validate(errors,
                                    validations.ERR_REDECLARED_VARIABLE(originTask.id, value),
                                    true
                                );
                            }
                        });
                    }
                }
                // 2.b Validate reserved keyword "new"
                errors = validations.validate(errors, validations.ERR_RESERVED_KEYWORD(flowTask.id, "new"), (
                    value.toLowerCase() === "new"
                ));
                // Set errors
                if (errors.length != 0) {
                    flowTask.errors = {
                        ...flowTask.errors,
                        [name]: errors
                    };
                } else {
                    const {[name]:_, ...remainingErrors} = flowTask.errors;
                    flowTask.errors = {...remainingErrors};
                }
                // Update symbol table
                let meta = task.outputs![name];
                let variable: NamedFlowVariable = {
                    name: value,
                    type: meta.type,
                    scope: "local",
                    displayName: "",
                    description: meta.description,
                    declaredBy: flowTask.id
                };
                if (variable.type === "array") {
                    variable.items = {
                        type: meta.items!.type,
                    };
                }
                curVariables[value] = variable;
                if (curVariablesOrigin[value] === undefined) {
                    curVariablesOrigin[value] = [];
                }
                curVariablesOrigin[value].push(flowTask.id);
            }
        }
        // Recursively validate subtasks
        for (let subtasksHead of Object.values(current.children as object)) {
            _semanticValidation(
                flowTasks,
                subtasksHead,
                allVariables,
                curVariables,
                curVariablesOrigin,
                tasks
            );
        }
        current = (current.next as FlowTaskNode);
    }
}
